<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>DIV2js</title>
    <meta name="description" content="My personal intent of translating DIV to JavaScript.">
    <meta name="author" content="Salvador de la Puente GonzÃ¡lez">

    <link rel="stylesheet" href="../lib/reveal/css/reveal.css"/>
    <link rel="stylesheet" href="../lib/reveal/css/theme/mozilla-devrel-light.css"/>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../lib/reveal/lib/css/solarized-light.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../lib/reveal/css/print/pdf.css' : '../lib/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <header>
            <h1>DIV2js</h1>
            <p>An ugly presentation about transpilation</p>
          </header>
        </section>

        <section data-markdown>
          ## Disclaimer
          Yes, I know [DIV Go](http://www.divgo.net/), I know
          [the source code is on GitHub](https://github.com/DIVGAMES/DIV-Games-Studio)
          and I also know this is probably a useless project but, you know?
          **I don't care.**
        </section>

        <section data-markdown>
          ## Index
          1. How does DIV work?
          2. The execution model
          3. The memory model
          4. The execution pipeline
        </section>

        <section>
          <section data-markdown>
            ## How does DIV work?
          </section>

          <section data-markdown>
            ![DIV2 running on DOS-BOX](./imgs/div2-dosbox.png)
          </section>

          <section data-markdown>
            DIV programs have a point of entry...
          </section>

          <section data-markdown>
            ![DIV2 main program](./imgs/div2-main-program.png)
          </section>

          <section data-markdown>
            ...and a set of processes.
          </section>

          <section data-markdown>
            ![DIV2 processes](./imgs/div2-processes.png)
          </section>

          <section data-markdown>
            DIV2 processes are similar to Linux processes in a single-thread.
          </section>

          <section data-markdown>
            They run for a while, until executing a `FRAME` sentence.
            ![Processes list](./imgs/processes-list.png)
          </section>

          <section data-markdown>
            ![Process Execution](./imgs/div2-process-execution.png)
          </section>

          <section data-markdown>
            When all the processes have executed `FRAME`, the graphic engine draws a new frame.
          </section>

          <section data-markdown>
            And the execution continues **after the `FRAME`**...
            ![Resume process list](./imgs/resume-execution.png)
            ...until finding another one.
          </section>

          <section data-markdown>
            ![Next frame](./imgs/div2-process-execution-next-frame.png)
          </section>

          <section data-markdown>
            Do you know what in JavaScript is very similar to this?
          </section>

          <section data-markdown>
            A [generator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*)!

            ```js
            function* process() {
              let counter = 0;
              while (true) {
                yield counter; // This is like FRAME.
                counter++;
              }
            }
            ```
          </section>

          <section data-markdown>
            ![Process hierarchy](./imgs/div2-process-hierarchy.png)
            Processes have a hierarchy, a type, an ID...
          </section>

          <section data-markdown>
            ...and memory.
          </section>

          <section data-markdown>
            DIV memory is **manually managed**.
          </section>

          <section data-markdown>
            ![DIV2 Memory](./imgs/memory.png)

            It is a continous chunk of 4-byte aligned space.
          </section>

          <section data-markdown>
            And you know what in JavaScript is very similar to this?
          </section>

          <section data-markdown>
            A [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)!

            ```js
            const memory = new Int32Array(5); // 5 32-bit intenger cells.
            const ANGLE = 2;
            memory[ANGLE] = 90000;     // Variable assignation.
            memory[ANGLE + 1] = 90000; // Pointer aritmethic!
            ```
          </section>
        </section>

        <section>
          <section data-markdown>
            ## The execution model
          </section>

          <section data-markdown>
            Let's consider generators.
          </section>

          <section data-markdown>
            With generators, a DIV process...

            ```div
            PROCESS asteroid()
            BEGIN
              graph = 1;
              WHILE (NOT out_of_region(ID, 0))
                graph = ((graph + 1) % 10 + 1);
                y += 10;
                FRAME;
              END
            END
            ```
          </section>

          <section data-markdown>
            ...would be translated into a JavaScript generator:
            ```js
            function* asteroid(mem) {
              const GRAPH = 100;
              const Y     = 101;
              mem[GRAPH] = 1;
              while (!out_of_region(mem[ID], 0)) {
                mem[GRAPH] = ((mem[GRAPH] + 1) % 10 + 1);
                mem[Y] += 10;
                yield { type: 'frame', completion: 100 };
              }
            }
            ```
          </section>

          <section data-markdown>
            Creating a new process would look like:

            ```js
            function newProcess(name, args) {
              const processType = processes[name];
              const mem = new Int32Array(PROCESS_SIZE);
              initializeMemory(mem, args);
              const process = processType(mem);
              process.mem = mem;
              processList.push(process);
            }
            ```
          </section>

          <section data-markdown>
            And the scheduler would look like this:

            ```js
            function runProcessList() {
              let retValue;
              while (processList.length) {
                for (let i = 0, current; current = processList[i]; i++) {
                  const result = current.next(retValue); // run until yield.
                  retValue = handle(result, current.mem);
                };
                drawFrame();
              }
            }
            ```
          </section>

          <section data-markdown>
            `handle()` would manipulate the process list according to the result of the execution of
            the process.
          </section>

          <section data-markdown>
            `retValue` is sent to the process since some statements can return values (i.e. _calling a process returns its ID_).
          </section>

          <section data-markdown>
            * `FRAME` continues with the next process.
            * `&lt;EOP&gt;` removes the process from the list.
            * `anotherProcess()` adds a new process to the list.
            * `DEBUG` starts the debugger, then continues with the current process.
            * `CLONE` adds a new process, copying the state of the current process.
          </section>

          <section data-markdown>
            WAIT A SECOND!
          </section>

          <section data-markdown>
            `CLONE` does **WHAT!?**
          </section>

          <section data-markdown>
            ```div
            PROGRAM test;
            BEGIN
              write_int(0, 0, 0, 0, ID);
              write(0, 0, 10, 0, "Only the parent.");
              CLONE
                x = 100;
                write_int(0, x, 20, 0, ID);
                write(0, x, 30, 0, "Only the child.");
              END
              write_int(0, x, 40, 0, ID);
              write(0, x, 50, 0, "Both.");
              LOOP FRAME; END // alt+x to quit
            END
            ```
          </section>

          <section data-markdown>
            ![Clone execution](./imgs/clone-execution.png)
          </section>

          <section data-markdown>
            Here is the problem: copying the memory state is possible but **copying the execution state is not**.
          </section>

          <section data-markdown>
            So I tried [the standard way](https://esdiscuss.org/topic/proposal-generator-clone-and-generator-goto).

            ![Discussion about adding generator#clone and generator#goto](./imgs/generator-clone.png)
          </section>

          <section data-markdown>
            I knew the solution was a state machine...
          </section>

          <section>
            <iframe src="http://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=latest%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&experimental=false&loose=false&spec=false&code=function*%20asteroid(mem)%20%7B%0A%20%20const%20GRAPH%20%3D%20100%3B%0A%20%20const%20Y%20%20%20%20%20%3D%20101%3B%0A%20%20mem%5BGRAPH%5D%20%3D%201%3B%0A%20%20while%20(!out_of_region(mem%5BID%5D%2C%200))%20%7B%0A%20%20%20%20mem%5BGRAPH%5D%20%3D%20((mem%5BGRAPH%5D%20%2B%201)%20%25%2010%20%2B%201)%3B%0A%20%20%20%20mem%5BY%5D%20%2B%3D%2010%3B%0A%20%20%20%20yield%20%7B%20type%3A%20'frame'%2C%20completion%3A%20100%20%7D%3B%0A%20%20%7D%0A%7D&amp;playground=true" width="100%" height="800px" frameborder="0"></iframe>
          </section>

          <section data-background-image="./imgs/babel-extension.jpg">

          </section>

          <section data-background-image="./imgs/totally-inefficient.jpg">

          </section>

          <section data-markdown>
            So [I wrote my own](https://github.com/delapuente/div2js/blob/master/src/context.js#L139).
          </section>

          <section data-markdown>
            This is how translating `CLONE` looks like:
            ```js
            translators.CloneSentence = function (divClone, context) {
              var insideCloneLabel = context.newLabel();
              var afterCloneLabel = context.newLabel();
              context.clone(insideCloneLabel, afterCloneLabel);
              context.label(insideCloneLabel);
              translateBody(divClone, context);
              context.label(afterCloneLabel);
            };
            ```
          </section>

          <section data-markdown>
            And this is how the `CLONE` example looks once transpiled:
            ```js
            function program_test(mem, exec, args) {
              while (true) {
                switch (exec.pc) {
                  case 1:
                    return __yieldCallFunction(2, 'write_int', [0, 0, 0, 0, mem[ID]]);
                  case 2:
                    exec.retv.dequeue();
                    return __yieldCallFunction(4, 'write', [0, 0, 10, 0, 'Only the parent.']);
                  case 4:
                    exec.retv.dequeue();
                    return __yieldClone(6, 11);
                  case 6:
                    mem[x] = 100;
                    return __yieldCallFunction(8, 'write_int', [0, mem[x], 20, 0, mem[ID] ]);
                  case 8:
                    exec.retv.dequeue();
                    return __yieldCallFunction(10, 'write', [0, mem[x], 30, 0, 'Only the child.']);
                  case 10:
                    exec.retv.dequeue();
                  case 11:
                    return __yieldCallFunction(12, 'write_int', [0, mem[x], 40, 0, mem[ID]]);
                  case 12:
                    exec.retv.dequeue();
                    return __yieldCallFunction(14, 'write', [0, mem[x], 50, 0, 'Both.']);
                  case 14:
                    exec.retv.dequeue();
                  case 15:
                    exec.pc = 15;
                    break;
                  case 16:
                    return __yieldEnd;
                }
              }
            }
            ```
          </section>

          <section data-markdown>
            ### DEBUGGING
          </section>

          <section data-markdown>
            You migh be wondering **why so many yields**?
          </section>

          <section data-markdown>
            Is it necessary to yield on **every** call?
          </section>

          <section>
            <p>It is.</p>
            <p class="fragment">(<a href="https://github.com/delapuente/div2js/commit/13042a266614c95e37231f0eea2701f8d14495df">if you want to debug it</a>)</p>
          </section>

          <section data-markdwon>
            Because you need to return to the scheduler to have the opportunity of launching the debugger.
          </section>
        </section>

        <section>
          <section data-markdown>
            ## The memory model
          </section>

          <section data-markdown>
            Each process has a _reserved_ memory region.
          </section>

          <section data-markdown>
            ![Local data](./imgs/div2-local-data.png)
          </section>

          <section>
            <p>Implementation goal:</p>
            <p class="fragment"><strong>Preserve pointer semantics <em>across</em> regions.</strong></p>
          </section>

          <section data-markdown>
            ### Process size
          </section>

          <section data-markdown>
            Kind reminder:
          </section>

          <section data-markdown>
            Memory is a `Int32Array`
            ```
            const mem = new Int32Array(PROCESS_SIZE);
            ```
          </section>

          <section data-markdown>
            So, first question, what is `PROCESS_SIZE`?
          </section>

          <section data-markdown>
            Hypothesis: _with no privates, size of the process is size of locals_.
          </section>

          <section data-background-image="./imgs/id-is-offset.jpeg">
          </section>

          <section data-markdown>
            Gut feeling: _`ID` is the address of the process_.
          </section>

          <section data-markdown>
            According to the debugger, there are **44 locals**.
          </section>

          <section data-markdown>
            ```div
            PROGRAM calc_process_size;
            BEGIN
              p();
              p();
              DEBUG;
            END

            PROCESS p();
            BEGIN
              LOOP FRAME; END
            END
            ```
          </section>

          <section data-markdown>
            ![Substracting one process ID fron another, you have the process size](./imgs/div2-process-size.png)
          </section>

          <section>
            <p>
              1751 - 1707 = <strong>44</strong>; 1795 - 1751 = <strong>44</strong>
            </p>
            <p class="fragment">Fair enough.</p>
          </section>

          <section data-markdown>
            Hypothesis: _with privates, size of the process is size of locals + privates_.
          </section>

          <section data-markdown>
            ```div
            PROGRAM calc_process_size;
            BEGIN
              p();
              q();
              DEBUG;
            END

            PROCESS p();
            PRIVATE
              a;
            BEGIN
              LOOP FRAME; END
            END

            PROCESS q();
            PRIVATE
              a;
              b;
            BEGIN
              LOOP FRAME; END
            END
            ```
          </section>

          <section data-markdown>
            ![Size is constant](./imgs/div2-constant-size.png)
          </section>

          <section>
            <p>
              1769 - 1723 = <strong>46</strong>; 1815 - 1769 = <strong>46</strong>
            </p>
            <p class="fragment">WTF?</p>
          </section>

          <section data-markdown>
            So, DIV has a fixed process size, which is the sum of local segment and the biggest private region.
          </section>

          <section data-markdown>
            ![Process memory region](./imgs/memory-segment.png)

            Regions include enough space for _locals_ and _private_ variables.
          </section>

          <section data-markdown>
            In addition to a fixed number of process, the design leads to:
            * Fixed program footprint.
            * Very fast process allocation.
          </section>

          <section data-markdown>
            ### Memory map
          </section>

          <section data-markdown>
            Variable names will be array indices
            ```
            mem[X] = 10; // x = 10
            mem[Y] = 10; // y = 10
            ```
          </section>

          <section data-markdown>
            So, second question is, where is the data inside these regions?
          </section>

          <section data-markdown>
            What is the first variable?

            ```div
            PROGRAM memory_map;
            PRIVATE
              pid;
            BEGIN
              pid = p();
              (*pid) = 1234567890;
              DEBUG;
            END

            PROCESS p();
            BEGIN
              LOOP FRAME; END
            END
            ```
          </section>

          <section data-markdown>
            ![First local is process id](./imgs/div2-first-local.png)
          </section>

          <section data-markdown>
            Where are the other?

            ```div
            PROGRAM memory_offsets;
            PRIVATE
              target;
              result;
            BEGIN
              target = &amp;reserved.id_scan;
              result = target - ID;
              write_int(0, 0, 0, 0, &amp;result);
              LOOP FRAME; END
            END
            ```
          </section>

          <section data-markdown>
            ![id_scan offset is 1](./imgs/div2-memory-locations.png)
          </section>

          <section data-markdown>
            Double check privates come after locals.

            ```div
            PROGRAM segment_order;
            PRIVATE
              a;
            BEGIN
              *(ID + 44) = 1234567890;
              DEBUG;
            END
            ```
          </section>

          <section data-markdown>
            ![Privates goes after locals](./imgs/div2-segment-order.png)
          </section>

          <section data-markdown>
            ### Pointer arithmetic
          </section>

          <section data-markdown>
            Pointer airthmetic goes in between the brackets
            ```js
            mem[X] = mem[MOUSE_STRUCT + MOUSE_X]; // x = mouse.x
            ```
          </section>

          <section data-markdown>
            ### Globals and text segments
          </section>

          <section data-markdown>
            Is it possible to achieve total pointer compatibility?
          </section>

          <section data-markdown>
            Yes, if processes receive **all the memory**.
          </section>

          <section data-markdown>
            Fortunately, source is now on GitHub so [figuring
            out global memory](https://github.com/DIVGAMES/DIV-Games-Studio/blob/0c006cca548f9d6dc66d174d4f05d167148c7e78/dll/div.h) map was much easier.
          </section>

          <section>
            <ul>
              <li>So, where the globals are?</li>
              <li class="fragment">And the text of the program?</li>
              <li class="fragment">Are there gaps in between?</li>
            </ul>
          </section>
        </section>

        <section>
          <section data-markdown>
            ## The Execution Pipeline
          </section>

          <section data-markdown>
            The process to execute a DIV program
            traverses several stages.
          </section>

          <section data-markdown>
            1. Transpilation
            2. Load
            3. Execution
          </section>

          <section data-markdown>
            ### Transpilation
          </section>

          <section data-markdown>
            Is the process for which a DIV program is translated into a JavaScript.
          </section>

          <section data-markdown>
            ```div
            PROGRAM test;
            BEGIN
              text_z = 1;
              DEBUG;
              a();
              DEBUG;
              text_z = 3;
              DEBUG;
            END

            PROCESS a();
            BEGIN
              text_z = 2;
            END
            ```
          </section>

          <section data-markdown>
            During **parsing**, source code is translated into a **DIV Abstract Syntax Tree**.
          </section>

          <section data-markdown>
```js
{
  "type": "Unit",
  "program": {
    "type": "Program",
    "name": {
      "type": "Identifier",
      "name": "test"
    },
    "consts": null,
    "globals": null,
    "locals": null,
    "privates": null,
    "body": {
      "type": "ProcessBody",
      "sentences": [
        {
          "type": "ExpressionSentence",
          "expression": {
            "type": "AssignmentExpression",
            "operator": "=",
            "left": {
              "type": "Identifier",
              "name": "text_z"
            },
            "right": {
              "type": "Literal",
              "value": 1,
              "raw": "1"
            }
          }
        },
        {
          "type": "DebugSentence"
        },
        {
          "type": "ExpressionSentence",
          "expression": {
            "type": "CallExpression",
            "callee": {
              "type": "Identifier",
              "name": "a"
            },
            "arguments": []
          }
        },
        {
          "type": "DebugSentence"
        },
        {
          "type": "ExpressionSentence",
          "expression": {
            "type": "AssignmentExpression",
            "operator": "=",
            "left": {
              "type": "Identifier",
              "name": "text_z"
            },
            "right": {
              "type": "Literal",
              "value": 3,
              "raw": "3"
            }
          }
        },
        {
          "type": "DebugSentence"
        }
      ]
    }
  },
  "processes": [
    {
      "type": "Process",
      "name": {
        "type": "Identifier",
        "name": "a"
      },
      "privates": null,
      "body": {
        "type": "ProcessBody",
        "sentences": [
          {
            "type": "ExpressionSentence",
            "expression": {
              "type": "AssignmentExpression",
              "operator": "=",
              "left": {
                "type": "Identifier",
                "name": "text_z"
              },
              "right": {
                "type": "Literal",
                "value": 2,
                "raw": "2"
              }
            }
          }
        ]
      }
    }
  ]
}
```

[JISON](http://zaa.ch/jison/) is used to write the grammar and parse the source code.
          </section>

          <section data-markdown>
            > JISON: Your friendly JavaScript parser generator!

            [_friendly_](https://github.com/delapuente/div2js/blob/master/src/grammar.y)
          </section>

          <section data-markdown>
            The **semantic checker** runs now (which includes the type checker) extracting the enough context to drive the translation.
          </section>

          <section data-markdown>
            ```js
            {
              "_processes": {
                "a": true
              },
              "_auxNames": {},
              "_currentProcessPrivates": {}
            }
            ```
          </section>

          <section data-markdown>
            With the DIV AST + context, the translator has
            enough information to create a **JavaScript AST**.
          </section>

          <section data-markdown>
```js
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "G_BASE"
          },
          "init": {
            "type": "Literal",
            "value": 0,
            "raw": "0"
          }
        },
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "G_TEXT_Z"
          },
          "init": {
            "type": "Literal",
            "value": 0,
            "raw": "0"
          }
        }
      ],
      "kind": "var"
    },
    {
      "type": "FunctionDeclaration",
      "id": {
        "type": "Identifier",
        "name": "program_test"
      },
      "params": [
        {
          "type": "Identifier",
          "name": "mem"
        },
        {
          "type": "Identifier",
          "name": "exec"
        },
        {
          "type": "Identifier",
          "name": "args"
        }
      ],
      "defaults": [],
      "body": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "WhileStatement",
            "test": {
              "type": "Literal",
              "value": true,
              "raw": "true"
            },
            "body": {
              "type": "BlockStatement",
              "body": [
                {
                  "type": "SwitchStatement",
                  "discriminant": {
                    "type": "MemberExpression",
                    "computed": false,
                    "object": {
                      "type": "Identifier",
                      "name": "exec"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "pc"
                    }
                  },
                  "cases": [
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 1,
                        "raw": "1"
                      },
                      "consequent": [
                        {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "computed": true,
                              "object": {
                                "type": "Identifier",
                                "name": "mem"
                              },
                              "property": {
                                "type": "BinaryExpression",
                                "operator": "+",
                                "left": {
                                  "type": "Identifier",
                                  "name": "G_BASE"
                                },
                                "right": {
                                  "type": "Identifier",
                                  "name": "G_TEXT_Z"
                                }
                              }
                            },
                            "right": {
                              "type": "Literal",
                              "value": 1,
                              "raw": "1"
                            }
                          }
                        },
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "__yieldDebug"
                            },
                            "arguments": [
                              {
                                "type": "Literal",
                                "value": 3,
                                "raw": "3"
                              }
                            ]
                          }
                        }
                      ]
                    },
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 3,
                        "raw": "3"
                      },
                      "consequent": [
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "__yieldNewProcess"
                            },
                            "arguments": [
                              {
                                "type": "Literal",
                                "value": 4,
                                "raw": "4"
                              },
                              {
                                "type": "Literal",
                                "value": "a",
                                "raw": "\"a\""
                              },
                              {
                                "type": "ArrayExpression",
                                "elements": []
                              }
                            ]
                          }
                        }
                      ]
                    },
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 4,
                        "raw": "4"
                      },
                      "consequent": [
                        {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "MemberExpression",
                              "computed": false,
                              "object": {
                                "type": "MemberExpression",
                                "computed": false,
                                "object": {
                                  "type": "Identifier",
                                  "name": "exec"
                                },
                                "property": {
                                  "type": "Identifier",
                                  "name": "retv"
                                }
                              },
                              "property": {
                                "type": "Identifier",
                                "name": "dequeue"
                              }
                            },
                            "arguments": []
                          }
                        },
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "__yieldDebug"
                            },
                            "arguments": [
                              {
                                "type": "Literal",
                                "value": 6,
                                "raw": "6"
                              }
                            ]
                          }
                        }
                      ]
                    },
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 6,
                        "raw": "6"
                      },
                      "consequent": [
                        {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "computed": true,
                              "object": {
                                "type": "Identifier",
                                "name": "mem"
                              },
                              "property": {
                                "type": "BinaryExpression",
                                "operator": "+",
                                "left": {
                                  "type": "Identifier",
                                  "name": "G_BASE"
                                },
                                "right": {
                                  "type": "Identifier",
                                  "name": "G_TEXT_Z"
                                }
                              }
                            },
                            "right": {
                              "type": "Literal",
                              "value": 3,
                              "raw": "3"
                            }
                          }
                        },
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "CallExpression",
                            "callee": {
                              "type": "Identifier",
                              "name": "__yieldDebug"
                            },
                            "arguments": [
                              {
                                "type": "Literal",
                                "value": 8,
                                "raw": "8"
                              }
                            ]
                          }
                        }
                      ]
                    },
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 8,
                        "raw": "8"
                      },
                      "consequent": [
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "__yieldEnd"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      "generator": false,
      "expression": false
    },
    {
      "type": "FunctionDeclaration",
      "id": {
        "type": "Identifier",
        "name": "process_a"
      },
      "params": [
        {
          "type": "Identifier",
          "name": "mem"
        },
        {
          "type": "Identifier",
          "name": "exec"
        },
        {
          "type": "Identifier",
          "name": "args"
        }
      ],
      "defaults": [],
      "body": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "WhileStatement",
            "test": {
              "type": "Literal",
              "value": true,
              "raw": "true"
            },
            "body": {
              "type": "BlockStatement",
              "body": [
                {
                  "type": "SwitchStatement",
                  "discriminant": {
                    "type": "MemberExpression",
                    "computed": false,
                    "object": {
                      "type": "Identifier",
                      "name": "exec"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "pc"
                    }
                  },
                  "cases": [
                    {
                      "type": "SwitchCase",
                      "test": {
                        "type": "Literal",
                        "value": 1,
                        "raw": "1"
                      },
                      "consequent": [
                        {
                          "type": "ExpressionStatement",
                          "expression": {
                            "type": "AssignmentExpression",
                            "operator": "=",
                            "left": {
                              "type": "MemberExpression",
                              "computed": true,
                              "object": {
                                "type": "Identifier",
                                "name": "mem"
                              },
                              "property": {
                                "type": "BinaryExpression",
                                "operator": "+",
                                "left": {
                                  "type": "Identifier",
                                  "name": "G_BASE"
                                },
                                "right": {
                                  "type": "Identifier",
                                  "name": "G_TEXT_Z"
                                }
                              }
                            },
                            "right": {
                              "type": "Literal",
                              "value": 2,
                              "raw": "2"
                            }
                          }
                        },
                        {
                          "type": "ReturnStatement",
                          "argument": {
                            "type": "Identifier",
                            "name": "__yieldEnd"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      "generator": false,
      "expression": false
    }
  ]
}
```

The output AST follows the [ESTree](https://github.com/estree/estree) specification which is based in the [Mozilla Parser API](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API).
          </section>

          <section data-markdown>
            Which is the AST for this:

```js
var G_BASE = 0, G_TEXT_Z = 0;
function program_test(mem, exec, args) {
  while (true) {
    switch (exec.pc) {
    case 1:
      mem[G_BASE + G_TEXT_Z] = 1;
      return __yieldDebug(3);
    case 3:
      return __yieldNewProcess(4, 'a', []);
    case 4:
      exec.retv.dequeue();
      return __yieldDebug(6);
    case 6:
      mem[G_BASE + G_TEXT_Z] = 3;
      return __yieldDebug(8);
    case 8:
      return __yieldEnd;
    }
  }
}

function process_a(mem, exec, args) {
  while (true) {
    switch (exec.pc) {
    case 1:
      mem[G_BASE + G_TEXT_Z] = 2;
      return __yieldEnd;
    }
  }
}
```
          </section>

          <section data-markdown>
            This AST is then combined with a fixed one,
            which contains a set of **bridge functions** to
            communicate with the runtime.
          </section>

          <section data-markdown>
            ```js
            (function (rt) {
              'use strict';

              /* Here comes the memory map */

              function __yieldDebug(npc) {
                return new rt.Baton('debug', { npc: npc });
              }

              function __yieldNewProcess(npc, processName, args) {
                return new rt.Baton('newprocess', {
                  npc: npc,
                  processName: processName,
                  args: args
                });
              }

              var __yieldEnd = new rt.Baton('end');

              return { /* Here come the process and memory maps */ };
            });
            ```

            [Esprima](http://esprima.org/) is used to parse the code above.
          </section>

          <section data-markdown>
            Now the &mdash;3rd party&mdash; **generator** ([escodegen](https://github.com/estools/escodegen)) can create the proper JavaScript code.
          </section>

          <section data-markdown>
```js
(function (rt) {
  'use strict';
  var G_BASE = 0, G_TEXT_Z = 0;
  function __yieldDebug(npc) {
    return new rt.Baton('debug', { npc: npc });
  }
  function __yieldNewProcess(npc, processName, args) {
    return new rt.Baton('newprocess', {
      npc: npc,
      processName: processName,
      args: args
    });
  }
  var __yieldEnd = new rt.Baton('end');
  return {
    pmap: {
      program: function program_test(mem, exec, args) {
        while (true) {
          switch (exec.pc) {
          case 1:
            mem[G_BASE + G_TEXT_Z] = 1;
            return __yieldDebug(3);
          case 3:
            return __yieldNewProcess(4, 'a', []);
          case 4:
            exec.retv.dequeue();
            return __yieldDebug(6);
          case 6:
            mem[G_BASE + G_TEXT_Z] = 3;
            return __yieldDebug(8);
          case 8:
            return __yieldEnd;
          }
        }
      },
      process_a: function process_a(mem, exec, args) {
        while (true) {
          switch (exec.pc) {
          case 1:
            mem[G_BASE + G_TEXT_Z] = 2;
            return __yieldEnd;
          }
        }
      }
    },
    mmap: {
      G: {
        G_BASE: 0,
        G_TEXT_Z: 0
      },
      L: {},
      P: {}
    }
  };
});
```
          </section>

          <section data-markdown>
            ### Load
          </section>

          <section data-markdown>
            Loading the program means linking the object artefact with the runtime to create a **executable program**.
          </section>

          <section data-markdown>
            First the unit is evaluated with `eval()` passing the runtime functions needed to communicate with the scheduler.

            ```js
            const unit = eval(objText)(runtime);
            const processMap = unit.pmap;
            const memoryMap = unit.mmap;
            ```
          </section>

          <section data-markdown>
            Now the process and memory maps are used to create a new program.

            ```js
            const program = new runtime.Runtime(processMap, memoryMap)
            ```
          </section>

          <section data-markdown>
            ### Execution
          </section>

          <section data-markdown>
            Before executing the program, we can listen for some events.

            ```js
            // Both events don't finish until resolving a promise.
            program.ondebug = () => openDebugger();
            program.onfinished = () => showFinishMessage();
            ```
          </section>

          <section data-markdown>
            But our real interest is to run the program.

            ```js
            program.run();
            ```
          </section>
        </section>

        <section>
          <img src="../imgs/contact/chibi.jpg" alt="me" style="border:none; width: 250px; height:auto;">
          <p>Salvador de la Puente GonzÃ¡lez</p>
          <p><a href="https://twitter.com/salvadelapuente">@salvadelapuente</a></p>
          <p><a href="http://github.com/delapuente">http://github.com/delapuente</a></p>
          <p><a href="https://delapuente.github.io/presentations/">https://delapuente.github.io/presentations/</a></p>
        </section>

        <section data-markdown>
          ## Questions?
        </section>
      </div>
    </div>

    <script src="../lib/reveal/lib/js/head.min.js"></script>
    <script src="../lib/reveal/js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: '../lib/reveal/plugin/markdown/marked.js' },
          { src: '../lib/reveal/plugin/markdown/markdown.js' },
          { src: '../lib/reveal/plugin/notes/notes.js', async: true },
          { src: './highlight.pack.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
